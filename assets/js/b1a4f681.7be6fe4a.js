"use strict";(self.webpackChunkstylable_io=self.webpackChunkstylable_io||[]).push([[6755],{5784:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var n=a(7462),s=(a(7294),a(3905)),r=a(814);const l={id:"extend",title:"Extend",pagination_next:null},o=void 0,i={unversionedId:"guides/handbook/extend",id:"guides/handbook/extend",title:"Extend",description:"In the Import Class chapter, we saw how we can import CSS classes and target them by composing a selector to target our desired parts.",source:"@site/docs/guides/handbook/extend.mdx",sourceDirName:"guides/handbook",slug:"/guides/handbook/extend",permalink:"/docs/guides/handbook/extend",draft:!1,editUrl:"https://github.com/wixplosives/stylable.io/edit/master/docs/guides/handbook/extend.mdx",tags:[],version:"current",frontMatter:{id:"extend",title:"Extend",pagination_next:null},sidebar:"Guides",previous:{title:"Import Class",permalink:"/docs/guides/handbook/import-class"}},p={},c=[{value:"Extend a stylesheet",id:"extend-a-stylesheet",level:2},{value:"Apply the extending class",id:"apply-the-extending-class",level:3},{value:"Access inner parts",id:"access-inner-parts",level:3},{value:"Access a state",id:"access-a-state",level:3},{value:"Extend multiple levels",id:"extend-multiple-levels",level:2}],d={toc:c};function m(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"In the ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/handbook/import-class"},"Import Class chapter"),", we saw how we can import CSS classes and target them by composing a selector to target our desired parts."),(0,s.kt)("p",null,"In this chapter, we'll see how to extend a stylesheet to target inner parts and states."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Current status:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="player.st.css"',title:'"player.st.css"'},".root {\n  -st-states: registered,\n              ranking(enum(first, second, third));\n}\n.avatar {}\n.username {}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="game.st.css"',title:'"game.st.css"'},'@st-import Player, [avatar, username] from "./player.st.css";\n\nPlayer {\n  background: blue;\n}\nPlayer .avatar {\n  border-radius: 50%;\n}\nPlayer .username {\n  text-transform: uppercase;\n}\n')),(0,s.kt)("p",null,"Previously, we manually customized the ",(0,s.kt)("inlineCode",{parentName:"p"},"Player")," component by creating a selector that includes a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator"},"descendant combinator")," between the ",(0,s.kt)("inlineCode",{parentName:"p"},"Player")," and our targeted parts. This selector is based on knowledge we have about the ",(0,s.kt)("inlineCode",{parentName:"p"},"Player")," component structure, but this structure might change in the future, and break our assumptions."),(0,s.kt)("h2",{id:"extend-a-stylesheet"},"Extend a stylesheet"),(0,s.kt)("p",null,"To help us abstract our selector, we'll extend the ",(0,s.kt)("inlineCode",{parentName:"p"},"Player")," stylesheet to gain access to the stylesheet API, letting us target inner parts using ",(0,s.kt)("a",{parentName:"p",href:"/docs/references/pseudo-elements"},"custom pseudo-elements"),"."),(0,s.kt)("p",null,"We'll first set the ",(0,s.kt)("inlineCode",{parentName:"p"},"-st-extends")," property with the value of the imported ",(0,s.kt)("inlineCode",{parentName:"p"},"Player")," stylesheet on the local ",(0,s.kt)("inlineCode",{parentName:"p"},"player")," class."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="game.st.css"',title:'"game.st.css"'},'@st-import Player from "./player.st.css";\n\n.player {\n    -st-extends: Player;\n}\n')),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Namespacing output"),(0,s.kt)(r.Z,{title:"game.st.css",language:"css",mdxType:"CodeBlock"},'@st-import Player from "./player.st.css";\n  \n/* customizing class, local namespace */\n.game__player {\n    -st-extends: Player;\n}')),(0,s.kt)("p",null,"We ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/handbook/import-class#stylesheet-root-selector"},"previously saw")," that we can't simply target an imported stylesheet, as that would affect all instances of it."),(0,s.kt)("p",null,"Here, by using the ",(0,s.kt)("inlineCode",{parentName:"p"},"-st-extends")," property on a local class, we are scoping these customizations to the subtree of our component stylesheet."),(0,s.kt)("h3",{id:"apply-the-extending-class"},"Apply the extending class"),(0,s.kt)("p",null,"To customize a ",(0,s.kt)("inlineCode",{parentName:"p"},"Player")," component instance using our local stylesheet, we will need to apply the extending local class to the instance of the component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"import Player from './player.jsx';\nimport { st, classes } from './game.st.css';\n\nconst Game = ({ className }) => (\n  <div className={st(classes.root, className)}>\n    <Player className={classes.player} />\n  </div>\n);\n")),(0,s.kt)("h3",{id:"access-inner-parts"},"Access inner parts"),(0,s.kt)("p",null,"We can now use the custom pseudo-element syntax to safely target the ",(0,s.kt)("inlineCode",{parentName:"p"},"avatar")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"username")," parts of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Player")," component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="game.st.css"',title:'"game.st.css"'},'@st-import Player from "./player.st.css";\n\n.player {\n  -st-extends: Player;\n}\n.player::avatar {\n  border-radius: 50%;\n}\n.player::username {\n  text-transform: uppercase;\n}\n')),(0,s.kt)("details",null,(0,s.kt)("summary",null,"Namespacing output"),(0,s.kt)(r.Z,{title:"game.st.css",language:"css",mdxType:"CodeBlock"},'@st-import Player from "./player.st.css";\n  \n.game__player {\n  -st-extends: Player;\n}\n.game__player .player__avatar {\n  border-radius: 50%;\n}\n.game__player .player__username {\n  text-transform: uppercase;\n}')),(0,s.kt)("h3",{id:"access-a-state"},"Access a state"),(0,s.kt)("p",null,"Similar to how we used custom pseudo-elements to access inner parts of a component externally, we can now target custom pseudo-classes (states) of our extended parts as well."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="game.st.css"',title:'"game.st.css"'},'@st-import Player from "./player.st.css";\n\n.player {\n  -st-extends: Player;\n}\n.player:ranking(first) {\n  background: gold;\n}\n/* ... */\n')),(0,s.kt)("h2",{id:"extend-multiple-levels"},"Extend multiple levels"),(0,s.kt)("p",null,"Let's say that we want to turn our current ",(0,s.kt)("inlineCode",{parentName:"p"},"avatar")," part, into a component to support a more complex design with separate elements for the ",(0,s.kt)("inlineCode",{parentName:"p"},"frame")," and the ",(0,s.kt)("inlineCode",{parentName:"p"},"image"),"."),(0,s.kt)("p",null,"To do this, we'll create a new ",(0,s.kt)("inlineCode",{parentName:"p"},"avatar.st.css")," stylesheet, import it to ",(0,s.kt)("inlineCode",{parentName:"p"},"player.st.css"),", and extend our ",(0,s.kt)("inlineCode",{parentName:"p"},"avatar")," class with it."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="avatar.st.css"',title:'"avatar.st.css"'},".root {}\n.frame {}\n.image {}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="player.st.css"',title:'"player.st.css"'},'@st-import Avatar from "./avatar.st.css";\n\n.root {\n  -st-states: registered, \n              ranking(enum(first, second, third));\n}\n.avatar {\n  -st-extends: Avatar;\n}\n.username {}\n')),(0,s.kt)("p",null,"By extending a stylesheet, which in turn has a part that extends a stylesheet, we can target inner parts through multiple levels with code completion and validations."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="game.st.css"',title:'"game.st.css"'},'@st-import Player from "./player.st.css";\n\n.player {\n  -st-extends: Player;\n}\n\n/* all player instances have an avatar with a green frame*/\n.player::avatar::frame {\n  background: green;\n}\n\n/* the player in the first ranking, has an avatar with a golden frame */\n.player:ranking(first)::avatar::frame {\n  background: gold;\n}\n')),(0,s.kt)("admonition",{title:"Catch breaking changes",type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"Let's imagine a case, where the ",(0,s.kt)("inlineCode",{parentName:"p"},"Avatar")," component has undergone refactoring which changed the part name ",(0,s.kt)("inlineCode",{parentName:"p"},"frame")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"box"),". If we were using native CSS, and were aware of this change, we could try and manually locate all instances of ",(0,s.kt)("inlineCode",{parentName:"p"},"frame")," and replace them with ",(0,s.kt)("inlineCode",{parentName:"p"},"box"),". But if we were to miss an instance, CSS would provide no indication of the problem."),(0,s.kt)("p",{parentName:"admonition"},"Because we used Stylable to declare that a class extends a stylesheet, and then accessed its inner parts, we are assured that the interface exists and is valid, and if this interface were to change, an error would be reported at build-time and in the IDE.")),(0,s.kt)("hr",null),(0,s.kt)("p",null,"In this chapter we saw how once we extend a stylesheet, we can target inner parts and states using native-like syntax, while benefiting from language service features and diagnostics."),(0,s.kt)("p",null,"Next we'll start talking about features that have to do with style templating, beginning with variables, both native custom properties, and Stylable's build-time variables."),(0,s.kt)("admonition",{title:"You've reached the end of the handbook, so far",type:"info"},(0,s.kt)("p",{parentName:"admonition"},"This handbook is a work in progress and is not yet complete. You can track the plan and progress for it in ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/wixplosives/stylable.io/issues/39"},"this issue"))))}m.isMDXComponent=!0}}]);