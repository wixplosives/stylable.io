"use strict";(self.webpackChunkstylable_io=self.webpackChunkstylable_io||[]).push([[7963],{9948:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var n=s(5893),a=s(1151);const i={id:"custom-state",title:"Custom State"},o=void 0,r={id:"guides/handbook/custom-state",title:"Custom State",description:"In CSS, we have the ability to target native states of various elements using the pseudo-class syntax (for instance,active).",source:"@site/docs/guides/handbook/state.md",sourceDirName:"guides/handbook",slug:"/guides/handbook/custom-state",permalink:"/docs/guides/handbook/custom-state",draft:!1,unlisted:!1,editUrl:"https://github.com/wixplosives/stylable.io/edit/master/docs/guides/handbook/state.md",tags:[],version:"current",frontMatter:{id:"custom-state",title:"Custom State"},sidebar:"Guides",previous:{title:"Namespacing",permalink:"/docs/guides/handbook/namespacing"},next:{title:"Runtime",permalink:"/docs/guides/handbook/runtime"}},d={},c=[{value:"Define and target",id:"define-and-target",level:2},{value:"Runtime toggle",id:"runtime-toggle",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["In CSS, we have the ability to target native states of various elements using the ",(0,n.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes",children:(0,n.jsx)(t.code,{children:"pseudo-class"})})," syntax (for instance, ",(0,n.jsx)(t.code,{children:":hover"})," or ",(0,n.jsx)(t.code,{children:":active"}),")."]}),"\n",(0,n.jsxs)(t.p,{children:["While this is very handy, as of today, CSS does not provide a way for us to define a custom state on every element. For example, we might want a ",(0,n.jsx)(t.code,{children:"registered"})," custom state to represent a player element that has signed up for our game."]}),"\n",(0,n.jsxs)(t.p,{children:["We could choose to implement such a state manually by using a class selector (e.g. using a ",(0,n.jsx)(t.a,{href:"http://getbem.com/naming/#modifier:~:text=block__elem%20%7B%20color%3A%20%23042%3B%20%7D-,Modifier,-Flags%20on%20blocks",children:"BEM modifier"}),": ",(0,n.jsx)(t.code,{children:".NAMESPACE--registered"}),") or attribute selector (e.g. ",(0,n.jsx)(t.code,{children:"[data-NAMESPACE-registered]"}),")."]}),"\n",(0,n.jsx)(t.p,{children:"This is a bit of a pain for several reasons. Unlike native pseudo-classes, a class or an attribute selector is not semantic, and so we lose the original intent. If a convention like BEM is used, then the semantics are conserved, but it increases the verbosity of our code."}),"\n",(0,n.jsx)(t.p,{children:"By defining our states through Stylable, we gain the benefit of validations, completions, and a consistent syntax for states."}),"\n",(0,n.jsx)(t.h2,{id:"define-and-target",children:"Define and target"}),"\n",(0,n.jsxs)(t.p,{children:["To define a registered state for our ",(0,n.jsx)(t.code,{children:"player"})," class, we will use the ",(0,n.jsx)(t.code,{children:"-st-states"})," declaration, and pass it a single state name of ",(0,n.jsx)(t.code,{children:"registered"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["We can then target this state using our newly-defined ",(0,n.jsx)(t.code,{children:":registered"})," pseudo-class, knowing it will be transformed to a valid, safe selector at build time."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-css",metastring:'title="game.st.css"',children:".player {\n  -st-states: registered; /* definition */\n}\n.player:registered {}     /* usage */\n\n/* OUTPUT - namespace class and state */\n.game__player {}\n.game__player.game--registered {}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In the example above, we defined a ",(0,n.jsx)(t.code,{children:"registered"})," boolean state that can either be targeted, or not. Let's imagine, though, that in addition to the ",(0,n.jsx)(t.code,{children:"registered"})," state, we now want to highlight ",(0,n.jsx)(t.code,{children:"first"}),", ",(0,n.jsx)(t.code,{children:"second"}),", and ",(0,n.jsx)(t.code,{children:"third"})," ranking players."]}),"\n",(0,n.jsxs)(t.p,{children:["We can define such a state by passing the ",(0,n.jsx)(t.code,{children:"enum"})," parameter type to the ",(0,n.jsx)(t.code,{children:"ranking"})," state definition, and in it, list our possible options."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-css",metastring:'title="game.st.css"',children:".player {\n  -st-states: registered, \n              ranking(enum(first, second, third)); \n}\n\n.player:ranking(first)   {}    \n.player:ranking(second)  {}    \n.player:ranking(third)   {}     \n"})}),"\n",(0,n.jsxs)(t.p,{children:["There are additional parameter types, as well as validators, default values, and mapping capabilities to Stylable custom states. ",(0,n.jsx)(t.a,{href:"/docs/references/pseudo-classes",children:"Read more in the API reference"}),"."]}),"\n",(0,n.jsxs)(t.admonition,{title:"Conflicts with native",type:"caution",children:[(0,n.jsxs)(t.p,{children:['At this point, you may have noticed that we can define states that would conflict with native CSS ones. For example, we can define a "custom" state called ',(0,n.jsx)(t.code,{children:":hover"})," that would conflict with the native ",(0,n.jsx)(t.code,{children:":hover"})," pseudo-class."]}),(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-css",children:".player {\n  -st-states: hover;\n}\n.player:hover {} /* custom state, not the native one */\n"})}),(0,n.jsxs)(t.p,{children:["Due to this potentially confusing behavior, we ",(0,n.jsx)(t.strong,{children:"strongly recommend"})," against naming states that would conflict with native ones."]})]}),"\n",(0,n.jsx)(t.h2,{id:"runtime-toggle",children:"Runtime toggle"}),"\n",(0,n.jsx)(t.p,{children:"Now that we have defined our states, we want to be able to toggle them at runtime in our component."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:'title="game.jsx"',children:'import { cssStates, classes } from "./game.st.css";\n\n// create a registered first ranking player\n<div className={\n    classes.player + " " + cssStates({ \n      registered: true,\n      ranking: "first" \n    })}>\n</div>;\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Looking at the example above, we import the ",(0,n.jsx)(t.code,{children:"cssStates"})," function and the ",(0,n.jsx)(t.code,{children:"classes"})," mapping from our ",(0,n.jsx)(t.code,{children:"game.st.css"})," stylesheet. We then create a ",(0,n.jsx)(t.code,{children:"div"})," element to represent a ",(0,n.jsx)(t.em,{children:"registered"})," and ",(0,n.jsx)(t.em,{children:"first rank"})," player."]}),"\n",(0,n.jsx)(t.p,{children:"This example, where we manually concatenate the class and states, is quite verbose and potentially confusing. In the next chapter, we will explore Stylable's runtime feature set and see a cleaner way of working with states at runtime."})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>o});var n=s(7294);const a={},i=n.createContext(a);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);